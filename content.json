[{"title":"bat脚本批量启动应用程序 ","date":"2020-08-21T01:52:50.000Z","path":"2020/08/21/bat脚本批量启动应用程序/","text":"在windows上利用自动化脚本批量启动应用程序注意：路径里不要有中文有空格的情况 12345start &quot;&quot; &quot;D:\\Program Files\\Foxmail 7.2\\Foxmail.exe&quot;REM start &quot;&quot; &quot;C:\\Program Files (x86)\\Yinxiang Biji\\印象笔记\\Evernote.exe&quot;start &quot;&quot; &quot;C:\\Users\\Public\\Desktop\\Evernote&quot;start &quot;&quot; &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot;start &quot;&quot; &quot;D:\\VSCode\\Microsoft VS Code\\Code.exe&quot; 无空格的情况 12start D:\\Program Files\\Foxmail 7.2\\Foxmail.exe","tags":[{"name":"工具","slug":"工具","permalink":"https://loonmucy.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Element UI动态表格功能","date":"2020-08-21T01:47:17.000Z","path":"2020/08/21/Element-UI动态表格功能/","text":"Element UI动态表格功能123&lt;el-table ref&#x3D;&quot;detailTable&quot; class&#x3D;&quot;atb-table&quot; border size&#x3D;&quot;mini&quot; :data&#x3D;&quot;dataList&quot; v-loading&#x3D;&quot;loading&quot; height&#x3D;&quot;100%&quot; style&#x3D;&quot;width: 100%&quot;&gt; &lt;el-table-column v-for&#x3D;&quot;(item,index) in itemList&quot; :key&#x3D;&quot;index&quot; :prop&#x3D;&quot;item.prop&quot; :label&#x3D;&quot;item.label&quot;&gt;&lt;&#x2F;el-table-column&gt;&lt;&#x2F;el-table&gt; 接口数据格式1234567891011121314151617181920212223&#123; &quot;code&quot;: 0, &quot;msg&quot;: &quot;success&quot;, &quot;data&quot;: &#123; &quot;head&quot;: [ &quot;第一列&quot;, &quot;第二列&quot;, &quot;第三列&quot; ], &quot;body&quot;: [ [ &quot;第一行&quot;, 11, 12 ], [ &quot;第二行&quot;, 21, 22 ] ] &#125;&#125; 需要把数据格式整理成下面的结构123456789itemList: [ &#123;&#39;prop&#39;:&#39;prop0&#39;,&#39;label&#39;:&#39;第一列&#39;&#125;, &#123;&#39;prop&#39;:&#39;prop1&#39;,&#39;label&#39;:&#39;第二列&#39;&#125;, &#123;&#39;prop&#39;:&#39;prop2&#39;,&#39;label&#39;:&#39;第三列&#39;&#125;],dataList: [ &#123;&#39;prop0&#39;:&#39;第一行&#39;,&#39;prop1&#39;:&#39;11&#39;,&#39;prop2&#39;:&#39;12&#39;&#125;, &#123;&#39;prop0&#39;:&#39;第二行&#39;,&#39;prop1&#39;:&#39;21&#39;,&#39;prop2&#39;:&#39;22&#39;&#125;,] 整理逻辑如下1234567891011121314head.forEach((element,index) &#x3D;&gt; &#123; this.itemList.push(&#123; &#39;label&#39;:element, &#39;prop&#39;: &#39;prop&#39;+ index &#125;)&#125;);console.log(this.itemList)body.forEach((element,index) &#x3D;&gt; &#123; let objectm &#x3D; &#123;&#125; element.forEach((element1,index1) &#x3D;&gt; &#123; objectm[&#39;prop&#39;+index1] &#x3D; element1 &#125;); this.dataList.push(objectm)&#125;)","tags":[{"name":"vue","slug":"vue","permalink":"https://loonmucy.github.io/tags/vue/"},{"name":"ElementUI","slug":"ElementUI","permalink":"https://loonmucy.github.io/tags/ElementUI/"}]},{"title":"es6迭代器","date":"2020-08-21T01:42:23.000Z","path":"2020/08/21/es6迭代器/","text":"es6的集合对象类型Map、Set和数组，有如下迭代器用于搜索它们的内容 entries(): 返回一个包含键值对的迭代器； values(): 返回一个包含集合中的值得迭代器； keys(): 返回一个包含集合中的键的迭代器； 12345678910111213141516171819202122232425262728let colors &#x3D; [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;] let testObj &#x3D; [ &#123;&#39;id&#39;:&#39;id1&#39;,&#39;name&#39;:&#39;name1&#39;&#125;, &#123;&#39;id&#39;:&#39;id2&#39;,&#39;name&#39;:&#39;name2&#39;&#125;, &#123;&#39;id&#39;:&#39;id3&#39;,&#39;name&#39;:&#39;name3&#39;&#125;, ] let testObj1 &#x3D; &#123;&#39;id&#39;:&#39;id1&#39;,&#39;name&#39;:&#39;name1&#39;&#125; for(let entry of colors.entries()) &#123; console.log(entry) &#x2F;&#x2F; [0,&quot;red&quot;],[1,&quot;green&quot;],[2,&quot;blue&quot;] &#125; for(let entry of testObj.entries()) &#123; console.log(entry) &#x2F;&#x2F; [0,&#123;&#39;id&#39;:&#39;id1&#39;,&#39;name&#39;:&#39;name1&#39;&#125;],[1,&#123;&#39;id&#39;:&#39;id2&#39;,&#39;name&#39;:&#39;name2&#39;&#125;],[2,&#123;&#39;id&#39;:&#39;id3&#39;,&#39;name&#39;:&#39;name3&#39;&#125;] &#125; for(let values of testObj.values()) &#123; console.log(values) &#x2F;&#x2F; &#123;&#39;id&#39;:&#39;id1&#39;,&#39;name&#39;:&#39;name1&#39;&#125;,&#123;&#39;id&#39;:&#39;id2&#39;,&#39;name&#39;:&#39;name2&#39;&#125;,&#123;&#39;id&#39;:&#39;id3&#39;,&#39;name&#39;:&#39;name3&#39;&#125; &#125; for(let keys of testObj.keys()) &#123; console.log(keys) &#x2F;&#x2F; 0,1,2 &#125; for(let keys of Object.keys(testObj1)) &#123; console.log(keys) &#x2F;&#x2F; id,name &#125; for(let entries of Object.entries(testObj1)) &#123; console.log(entries) &#x2F;&#x2F; [&quot;id&quot;, &quot;id1&quot;],[&quot;name&quot;, &quot;name1&quot;] &#125; for(let values of Object.values(testObj1)) &#123; console.log(values) &#x2F;&#x2F; id1,name1 &#125;","tags":[{"name":"前端","slug":"前端","permalink":"https://loonmucy.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ES6","slug":"ES6","permalink":"https://loonmucy.github.io/tags/ES6/"}]},{"title":"map用法","date":"2020-08-21T01:36:01.000Z","path":"2020/08/21/map用法/","text":"以数组对象为例 取数组对象的某个属性和值1234567let arr &#x3D; [&#123;&#39;id&#39;:&#39;1&#39;,&#39;name&#39;:&#39;name1&#39;,&#39;age&#39;:&#39;10&#39;&#125;,&#123;&#39;id&#39;:&#39;2&#39;,&#39;name&#39;:&#39;name2&#39;,&#39;age&#39;:&#39;20&#39;&#125;,&#123;&#39;id&#39;:&#39;3&#39;,&#39;name&#39;:&#39;name3&#39;,&#39;age&#39;:&#39;30&#39;&#125;]console.log(arr.map(item&#x3D;&gt;item.name)) &#x2F;&#x2F;[&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;] 取数组对象的多个属性和值12console.log(arr.map((&#123;name,age&#125;) &#x3D;&gt; (&#123;name,age&#125;))) &#x2F;&#x2F;[&#123;name: &quot;name1&quot;, age: &quot;10&quot;&#125;,&#123;name: &quot;name2&quot;, age: &quot;20&quot;&#125;,&#123;name: &quot;name3&quot;, age: &quot;30&quot;&#125;]console.log(arr.map((&#123;age&#125;) &#x3D;&gt; (&#123;age&#125;))) &#x2F;&#x2F;[&#123;age: &quot;10&quot;&#125;,&#123;age: &quot;20&quot;&#125;,&#123;age: &quot;30&quot;&#125;]","tags":[{"name":"前端","slug":"前端","permalink":"https://loonmucy.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javaScript","slug":"javaScript","permalink":"https://loonmucy.github.io/tags/javaScript/"}]},{"title":"test","date":"2020-08-20T08:45:30.000Z","path":"2020/08/20/test/","text":"test888811111234","tags":[]},{"title":"Hello World","date":"2020-08-20T08:38:40.398Z","path":"2020/08/20/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"ES6新特性","date":"2018-04-15T13:04:28.000Z","path":"2018/04/15/ES6新特性/","text":"字符串模板ES6中我们可以使用反引号**`**（Tab上方）来创建字符串，并且可以在字符串中以$(变量名)的形式插入一个变量 12var num &#x3D; Math.random()console.log(&#96;your num is $(num)&#96;) let和const关键字let无变量提升12console.log(num) &#x2F;&#x2F; &#x3D;&gt; undefinedvar num &#x3D; 1 12console.log(num) &#x2F;&#x2F; &#x3D;&gt; ReferenceErrorlet num &#x3D; 1 使用var声明的变量会自动提升到当前作用域的顶部，如果声明位置与作用域顶部之间有另一个同名变量，很容易引起错误。使用let声明的变量不会进行变量提升，规避了这个隐患。 var声明的变量提升后虽然在声明语句之前输出为undefined，但这并不代表num变量还没有被声明，此时num变量已经完成声明并分配了相应内存，只是该变量目前的值为undefined 有块级作用域12345&#123; var num &#x3D; 1 console.log(num) &#x2F;&#x2F; &#x3D;&gt; 1&#125;console.log(num) &#x2F;&#x2F; &#x3D;&gt; 1 12345&#123; let num &#x3D; 1 console.log(num) &#x2F;&#x2F; &#x3D;&gt; 1&#125;console.lot(num) &#x2F;&#x2F; &#x3D;&gt; ReferenceError let声明的变量只能在当前块级作用域中使用 123for(let i &#x3D; 0, i &lt; 10; i++)&#123;&#125; 禁止重复声明123var dev &#x3D; truevar dev &#x3D; falseconsole.log(dev) &#x2F;&#x2F; &#x3D;&gt; false 12let dev &#x3D; truelet dev &#x3D; false &#x2F;&#x2F; &#x3D;&gt; SyntaxError var声明的变量可以重复声明，覆盖原来的值，不会有警告或提示，有隐患。let声明的变量不可以重复声明，否则会直接抛出一个语法错误。 const同上三点 无变量提升 有块级作用域 禁止重复声明 禁止重复赋值12const DEV &#x3D; trueDEV &#x3D; false &#x2F;&#x2F; &#x3D;&gt; TypeError 根据静态常量的定义可以知道，const声明的常量一经声明便不能再改其值。 必须赋初始值1const DEV &#x2F;&#x2F; &#x3D;&gt; SyntaxError const声明的常量既然一经声明，不能再改其值，那声明的时候不赋初始值显然不合理。一个没有值得常量只会浪费内存，没有意义。 箭头操作符=&gt;与lambda表达式有异曲同工之妙，它简化了函数的书写，操作符左边为输入的参数，右边是进行的操作和返回的值 inputs =&gt; outputsjs中经常用到回调，而一般回调又以匿名函数的形式出现，每次都需要写一个function，很繁琐。引入箭头函数后可以很方便的写回调了。 1234567var arr &#x3D; [1,2,3,4,5]&#x2F;&#x2F; beforearr.forEach(function(v)&#123; console.log(v);&#125;)&#x2F;&#x2F; ES6arr.forEach(v &#x3D;&gt; console.log(v)) 多个入参时需用括号包裹入参，单个入参时可省略括号 1234var arr &#x3D; [1,2,3,4,5,6]arr.map((v, k, thisArr) &#x3D;&gt; &#123; return thisArr.reverse()[k] * v;&#125;) &#x2F;&#x2F; [6,10,12,12,10,6] 函数上下文中的this 123456789101112131415161718192021&#x2F;&#x2F; beforevar obj &#x3D; &#123; arr: [1,2,3,4,5], getMaxPow2: function() &#123; var that &#x3D; this, getMax &#x3D; function() &#123; return Math.max.apply(&#123;&#125;, that.arr); &#125;; return Math.pow(getMax(), 2); &#125;&#125;&#x2F;&#x2F; ES6var obj &#x3D; &#123; arr: [1,2,3,4,5], getMaxPow2: function() &#123; var getMax &#x3D; () &#x3D;&gt; &#123; return Math.max.apply(&#123;&#125;, this.arr); &#125; return Math.pow(getMax(), 2); &#125;&#125; var that = this,声明一个临时变量that。在对象或原型链中，我们以前经常会写这样一个临时变量，that或_this，诸如此类，以达到在一个函数内部访问到父级或者祖先级this对象的目的。在箭头函数中，函数体内没有自己的this，默认在其内部调用this时，自动查找其父级上下文的this对象（如果父级也是箭头函数，则会按照作用域链继续向上查找），就不再需要多余的声明一个临时变量了。 注意： 在一些情况下可能需要函数有自己的this，例如DOM事件绑定时事件回调函数中，需要用this来操作当前的DOM，此时就需要使用传统匿名函数而非箭头函数。 在严格模式下，如果箭头函数的上层函数均为箭头函数，那么this对象将不可用。 由于箭头函数没有自己的this对象，所以箭头函数不能当做构造函数。 父级函数 arguments在函数体中有arguments这样一个伪数组对象，该对象中包含该函数所有的入参（显式入参 + 隐式入参）。当函数体中有另一个函数，且该函数为箭头函数时，该箭头函数的函数体中可以直接访问父级函数的arguments对象。 由于箭头函数本身没有arguments对象，所以如果它的上层函数都是箭头函数的话，那么arguments对象将不可用。 小结 共享父级this对象，arguments参数 不能当做构造函数 当箭头函数入参只有一个时可以省略入参括号 当入参多于一个或没有入参时必须有括号 当函数体只有一个return语句时，可以省略函数体的花括号与return关键字 类 &amp; 继承js时面向对象的，es6提供的类实际上只是js原型模式的包装，对象的创建、继承更加直观了，父类方法的调用，实例化，静态方法和构造函数等概念更加形象化。类的定义 12345678910111213141516171819202122232425262728&#x2F;* 类不会被提升 *&#x2F;let puppy &#x3D; new Animal(&#39;puppy&#39;); &#x2F;&#x2F; ReferenceErrorclass Animal &#123; constructor(name) &#123; this.name &#x3D; name; &#125; sleep() &#123; console.log(&#96;the $&#123;this.name&#125; is sleeping...&#96;); &#125; static type() &#123; console.log(&#96;this is an Animal class.&#96;); &#125;&#125;let puppy &#x3D; new Animal(&#39;puppy&#39;);puppy.sleep(); &#x2F;&#x2F; the puppy is sleeping...&#x2F;*实例化后无法访问静态方法*&#x2F;puppy.type(); &#x2F;&#x2F; TypeErrorAnimal.type(); &#x2F;&#x2F; this is an Animal class.&#x2F;*实例化前无法访问动态方法*&#x2F;Animal.sleep(); &#x2F;&#x2F; TypeError&#x2F;*类不能重复定义*&#x2F;class Animal() &#123;&#125; &#x2F;&#x2F; SyntaxError 类的定义中没有要求类名的大小写，鉴于代码规范，推荐类名首字母大写 类定义中有一特殊方法constructor()，该方法名固定，表示该类的构造函数（方法），在类的实例化过程中会被调用，new Animal(‘puppy’) 类中无法像对象一样使用prop: value或者prop = value 的形式定义一个类的属性，只能在类的构造方法或其他方法中使用this.prop = value的形式为类添加属性。 123456789101112&#x2F;&#x2F; beforefunction Animal(name) &#123; this.name &#x3D; name;&#125;Animal.prototype &#x3D; &#123; sleep: function() &#123; console.log(&#39;the&#39; + this.name + &#39;is sleeping...&#39;); &#125;&#125;;Animal.type &#x3D; function() &#123; console.log(&#39;this is an Animal class.&#39;);&#125; 类的继承 123456789101112131415161718192021class Programmer extends Animal &#123; constructor (name) &#123; &#x2F;*在super方法之前this不可用*&#x2F; console.log(this); &#x2F;&#x2F; ReferenceError super(name); console.log(this) &#125; program() &#123; console.log(&quot;I&#39;m coding...&quot;); &#125; sleep() &#123; console.log(&#39;save all files.&#39;); console.log(&#39;get into bed&#39;); super.sleep(); &#125;&#125;let coder &#x3D; new Programmer(&#39;coder&#39;);coder.program(); &#x2F;&#x2F; I&#39;m coding...coder.sleep(); &#x2F;&#x2F; save all files. get into bed. the coder is sleeping. 使用class定义类Programmer，使用extends关键字继承类Animal 若子类有构造方法，那么子类构造方法中使用this对象之前必须使用super()方法运行父类的构造方法以对父类进行初始化。 在子类方法中可以使用super对象来调用父类上的方法。 小结 本质为对原型链的二次包装 类没有提升 不能使用字面量定义属性 动态继承类的构造方法中super优先于this 模块将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入方式在其他地方使用。es6正式推出模块化规范 内联导出12345678910111213export const DEV &#x3D; true;export function example() &#123; &#x2F;&#x2F;...&#125;export class expClass &#123; &#x2F;&#x2F;...&#125;export let obj &#x3D; &#123; DEV, example, expClass, &#x2F;&#x2F;...&#125; 使用export关键字，后面紧跟声明关键字（let、function等）声明一个导出对象，这种声明并同时导出的方式称为内联导出。未被导出的内容（变量、函数、类等）由于独立代码块的原因，将仅供模块内部使用（类似闭包)。 对象导出1234567891011121314151617&#x2F;&#x2F; module example.jsconst DEV &#x3D; true;function example() &#123; &#x2F;&#x2F;...&#125;class expClass &#123; &#x2F;&#x2F;...&#125;let obj &#x3D; &#123; DEV, example, expClass, &#x2F;&#x2F;...&#125;&#x2F;&#x2F; module example.jsexport &#123;DEV,example,expClass,obj&#125;export &#123;DEV,example as exp,expClass,obj&#125; 我们可以像写普通js文件一样写主要的功能逻辑，最好通过export集中导出。导出时使用as关键字改变导出对象的名称。 默认导出123export default &#123;DEV,example as exp,expClass,obj&#125;;export default obj;export default const DEV &#x3D; true; 在export关键字后接default来设置模块的默认导出对象，一个模块只能有一个默认导出。 模块导入1234import example from &#39;.&#x2F;example.js&#39;;import default as example from &#39;.&#x2F;example.js&#39;import * as exp from &#39;.&#x2F;example.js&#39;&#x2F;&#x2F; 使用通配符*配合as关键字一次性导出模块中所有内容，最终导入的内容放在exp对象中 小结 封闭的代码块，每个模块都有自己完全独立的代码块，跟作用域类似，但更加封闭。 无限制导出，一个模块理论上可以导出无数个变量、函数、对象属性、对象方法、类。但是要合理控制代码颗粒度。 严格模式下运行，模块默认在（’use strick’）下运行","tags":[{"name":"前端","slug":"前端","permalink":"https://loonmucy.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ES6","slug":"ES6","permalink":"https://loonmucy.github.io/tags/ES6/"}]},{"title":"前端小结","date":"2017-12-07T05:24:38.000Z","path":"2017/12/07/前端小结/","text":"ES6新特性PromisePromise处理异步代码的代码可读性比回调机制要好；问题是如果没有处理Promise的reject，会导致错误被丢进黑洞。 面试问题跨域和前端解决跨域源于浏览器的同源策略限制，一级域名、二级域名、端口有一个不同，都属于跨域行为；前端解决跨域方法不多：Chrome可借助CORS插件代理同域请求到跨域接口；实际编码中可使用CORS(Cross-Origin-Resource-Sharin)和JSONP;JSONP的原理是利用 &lt;script&gt; 标签允许跨域资源请求的漏洞实现的，它使用&lt;script&gt;发送跨域请求，并使用一个callback参数将请求信息传递给服务器，服务器返回一个JS脚本包含我们指定的callback函数，然后我们执行callback即可获得服务器返回的内容；由于局限于&lt;script&gt;，所以JSONP只能发送GET请求；还有document.domain 或window.name等一些解决方案； web前端性能优化一般说来，web前端指网站业务逻辑之前的部分，包括浏览器加载、网站视图模型、图片服务、CDN服务等，主要优化手段有浏览器访问，使用反向代理、CDN等； 浏览器访问优化减少http请求，合理设置http缓存减少http的主要手段有合并CSS、合并JavaScript、合并图片恰当的缓存可以大大减少http请求：很少变化的图片资源可以直接通过http header中的Expires设置一个很长的过期头；变化不频繁又可能会变得资源可以使用Last-Modifed来做请求验证 使用浏览器缓存CSS Sprites合并CSS图片，减少请求数； 应用压缩压缩HTML、CSS、JS文件 CSS放在页面最上部，JS放在页面最下面JS代码优化1、DOM操作要考虑浏览器的Reflow和Repaint，这些需要消耗资源。2、避免用with、eval、Function 消耗资源、效率低、速度慢；3、减少作用域链查找，减少闭包使用；4、使用字符串拼接 CSS选择符优化异步请求CallbackCDN加速CDN缓存的一般是静态资源，如图片、文件、CSS、script脚本、静态网页等 反向代理同时可以实现负载均衡功能","tags":[{"name":"前端","slug":"前端","permalink":"https://loonmucy.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"测试","date":"2017-12-03T10:16:02.000Z","path":"2017/12/03/测试/","text":"","tags":[]},{"title":"前端知识点","date":"2017-11-08T07:46:28.000Z","path":"2017/11/08/前端知识点/","text":"块状元素与内联元素内联元素转化为块状元素： 1display: block; 内联元素不能设置宽和高，只能变成block,或inline-block才可以;","tags":[{"name":"前端","slug":"前端","permalink":"https://loonmucy.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"使用vue.js搭建项目","date":"2017-11-04T01:25:22.000Z","path":"2017/11/04/使用vue-js搭建项目/","text":"我的window10ssh hexo hhh","tags":[{"name":"前端","slug":"前端","permalink":"https://loonmucy.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://loonmucy.github.io/tags/vue/"}]},{"title":"搭建多终端同步的github + hexo静态博客","date":"2017-11-02T02:39:02.000Z","path":"2017/11/02/搭建多终端同步的github-hexo静态博客/","text":"前提条件拥有github账号本地终端安装git安装node.js github上创建个人主页新建仓库，名字与自己的用户名一致 从远程拉取仓库到本地git clone 仓库地址 本地 hexo 配置（核心）创建 hexo 分支1git checkout -b hexo 创建hexo分支并将其作为默认分支 备份原始的 .git 文件ll -a 查看目录下所有文件，发现有一个 .git 文件夹,该文件夹在后面push到hexo分支会有用，所以先备份一下在最后恢复； 安装hexo并初始化安装时要清空根目录文件夹（.git 文件夹已备份）依次执行如下命令： 1234npm install hexo //全局安装hexo的可以省略hexo initnpm installnpm install hexo-deployer-git --save 再恢复已经备份的 .git 文件夹，以免影响以后的push； 修改 _config.yml 中的deploy参数修改type 、repository、branch参数 将hexo分支push到远程hexo分支上执行： 123git add .git commit -m &quot;xxx&quot;git push origin hexo 此时hexo配置文件都被push到了远程hexo分支上 生成静态页面并部署执行hexo g -d将静态页面部署到master分支上。此时repo上有两个分支hexo（存储配置文件）和master（存储静态页面）；输入url即可看到博客页面。 日常上传博客流程在本地对博客进行修改（添加新博文，修改样式等）后，可通过以下流程管理。 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 执行hexo g -d发布网站到master分支上。1以后的操作全都在hexo分支上执行，不需要切换到master分支。 其他终端上传博客如果你想在另一个电脑上上传你自己的博客，那么你只需要如下做即可： 从repo仓库上将项目代码clone到本地。 此时本地只有master分支，切换到hexo分支。1git checkout -b hexo origin/hexo 此时查看拉下来的repo有没有.deploy_git文件夹，如果有的话，删除并重新安装本地的hexo-deployer。 12rm -r .deploy_gitnpm install hexo-deployer-git --save 搞定，之后按照步骤5即可完成上传。 git clone 后，直接npm install,然后 add，commit,push ,hexo g -d; 页面空白问题1、看看主题文件有没有加载上； hexo调试模式启动 Hexo 本地站点，并开启调试模式，命令： 1hexo s --debug","tags":[{"name":"前端","slug":"前端","permalink":"https://loonmucy.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"hexo","slug":"hexo","permalink":"https://loonmucy.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://loonmucy.github.io/tags/git/"}]},{"title":"浏览器 css reset 方法","date":"2017-10-31T06:57:33.000Z","path":"2017/10/31/浏览器-css-reset-方法/","text":"css reset 定义即重设浏览器样式；在各种浏览器中，都会对css的选择器默认一些数值（例如当h1没有被设置数值时，显示一定大小）；但并不是所有浏览器都使用一样的数值，所以有了css reset，以让网页的样式在各浏览器中表现一致。 css reset 方法简单方法1* &#123; padding: 0; margin: 0; border: 0; &#125; 简单、安全、强大，让所有选择器的padding、margin、border都设置成0；缺点是占用资源；对于小型的网站，用这个并不会带来大的资源浪费；但对于架构大的网站，则需要有选择地进行css重设，以减少资源浪费； Yahoo CSS Reset12345678910111213141516171819202122232425262728293031323334353637383940body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,p,blockquote,th,td &#123; padding: 0; margin: 0; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125; fieldset,img &#123; border: 0; &#125; address,caption,cite,code,dfn,em,strong,th,var &#123; font-weight: normal; font-style: normal; &#125; ol,ul &#123; list-style: none; &#125; caption,th&#123; text-align: left; &#125; h1,h2,h3,h4,h5,h6 &#123; font-weight: normal; font-size: 100%; &#125; q:before,q:after &#123; content:”; &#125; abbr,acronym &#123; border: 0; &#125; Ateneu Popular CSS Reset123456789101112131415161718192021222324252627282930313233343536373839404142434445464748html, body, div, span, applet, object, iframe, h1, h2, h3,h4, h5, h6, p, blockquote, pre, a, abbr, acronym,address, big, cite, code, del, dfn, em, font, img, ins,kbd, q, s, samp, small, strike, strong, sub, sup, tt,var, dl, dt, dd, ol, ul, li, fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td &#123; margin: 0; padding: 0; border: 0; outline: 0; font-weight: inherit; font-style: inherit; font-size: 100%; font-family: inherit; vertical-align: baseline; &#125; :focus &#123; outline: 0;&#125; a, a:link, a:visited, a:hover, a:active&#123; text-decoration:none&#125; table &#123; border-collapse: separate;border-spacing: 0;&#125; th, td &#123; text-align: left; font-weight: normal;&#125; img, iframe &#123; border: none; text-decoration:none;&#125; ol, ul &#123; list-style: none;&#125; input, textarea, select, button &#123; font-size: 100%;font-family: inherit;&#125; select &#123; margin: inherit;&#125; hr &#123; margin: 0;padding: 0;border: 0;color: #000;background-color: #000;height: 1px&#125;","tags":[{"name":"前端","slug":"前端","permalink":"https://loonmucy.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"https://loonmucy.github.io/tags/css/"}]},{"title":"hexo使用","date":"2017-10-31T01:13:08.000Z","path":"2017/10/31/hexo使用/","text":"hexo使用方法每次部署步骤，分三步：hexo cleanhexo generatehexo deploy 常用命令：hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本","tags":[{"name":"前端","slug":"前端","permalink":"https://loonmucy.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"hexo","slug":"hexo","permalink":"https://loonmucy.github.io/tags/hexo/"}]}]